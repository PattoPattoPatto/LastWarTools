# -*- coding: utf-8 -*-
"""ocr

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H4oJ4Sl3ub6S6ms0-VNC_8qeS7egGMqi

[Rac] Riz Maui

Warzone #27

[lolz] 베일 lolz

Warzone #27

[lolz] 도사 lolz

Warzone #27

[x3y] 空降

Warzone #27

[lolz] 폭주핑 lolz

Warzone #27

[Rac] Nada L

Warzone #27

[lolz] 우렁이 lolz

Warzone #27
"""

# Cell ID: 23994ede
!pip install opencv-python

!pip install paddlepaddle paddleocr

# Cell ID: Refactored Code - Block Creation, Pre-preparation, and OCR Parsing

import cv2
import numpy as np
from PIL import Image
import os
import re # Import regex for parsing

# --- Code from White Line Detection Cell (5bc64ad1 - Relevant parts for variable definition) ---
print("--- Loading Image and Performing White Line Detection ---")

# Replace 'your_image.png' with the path to your image file
image_path = 's27NameOnly.png' # Make sure this is the correct path

try:
    # Initialize variables that need to be accessible later
    img_cv2 = None
    gray_img = None
    player_blocks = []
    final_parsed_data_for_grouping_by_block = {} # From OCR processing


    # Load the image using OpenCV
    img_cv2 = cv2.imread(image_path, cv2.IMREAD_COLOR)

    if img_cv2 is None:
        raise FileNotFoundError(f"Error: Image not loaded. Check if the file exists at {image_path}")

    # Convert to grayscale for easier line detection
    gray_img = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2GRAY)

    # Define a threshold for white lines (adjust as needed)
    white_threshold = 240

    # Find rows that are predominantly white
    white_line_rows = []
    height, width = gray_img.shape

    for y in range(height):
        white_pixel_count = np.sum(gray_img[y, :] > white_threshold)
        white_percentage = (white_pixel_count / width) * 100

        if white_percentage > 90:
            white_line_rows.append(y)

    # Determine the boundaries of each player block based on white lines
    start_row = 0
    if white_line_rows and white_line_rows[0] > start_row + 10:
         player_blocks.append((start_row, white_line_rows[0]))
         start_row = white_line_rows[0] + 1
    elif not white_line_rows:
         player_blocks.append((start_row, height))
         start_row = height


    for i in range(len(white_line_rows) - 1):
        current_row = white_line_rows[i]
        next_row = white_line_rows[i+1]
        if next_row - current_row > 10:
            player_blocks.append((current_row + 1, next_row))

    if height - start_row > 10:
         last_white_line = white_line_rows[-1] if white_line_rows else 0
         last_block_start = last_white_line + 1 if white_line_rows else 0
         if height - last_block_start > 10:
              player_blocks.append((last_block_start, height))


    print(f"Detected {len(white_line_rows)} white lines at rows: {white_line_rows}")
    print(f"Identified {len(player_blocks)} player blocks.")
    print(f"Player block boundaries: {player_blocks}")

    # Check if player_blocks was successfully populated before proceeding
    if not player_blocks:
        print("Error: No player blocks identified. Cannot proceed.")
        # Exit the cell execution if no blocks are found
        raise ValueError("No player blocks identified.")

    print("-" * 40)
    # --- End of White Line Detection Code ---


    # --- Pre-preparation of Blocks (Placeholder - add specific steps here if needed) ---
    print("--- Pre-preparing Blocks (Placeholder) ---")
    # Add any pre-preparation steps here, e.g., basic noise reduction, scaling if necessary
    print("Basic block preparation complete (no specific steps added yet).")

    print("\n" + "="*40) # Separator

    # --- Code from Cell dfab5387 (Process and Associate PaddleOCR Data) ---
    print("--- Processing and Associating (by order) PaddleOCR Data ---")

    # Manually captured output from the successful English PaddleOCR run (from cell 0cceae62 output):
    # This output includes "Warzone #27" lines interspersed with player data.
    paddleocr_extracted_data_raw = """Text: [Rac] Riz Maui, Confidence: 0.98
Text: Warzone #27, Confidence: 0.99
Text: [lolz] 베일 lolz, Confidence: 0.95
Text: Warzone #27, Confidence: 0.99
Text: [lolz] 도사 lolz, Confidence: 0.94
Text: Warzone #27, Confidence: 0.99
Text: [x3y] 空降, Confidence: 0.97
Text: Warzone #27, Confidence: 0.99
Text: [1012] 폭주핑 lolz, Confidence: 0.93
Text: Warzone #27, Confidence: 0.99
Text: [Rac] Nada L, Confidence: 0.98
Text: Warzone #27, Confidence: 0.99
Text: [lolz] 우렁이 lolz, Confidence: 0.94
Text: Warzone #27, Confidence: 0.99
"""

    lines = paddleocr_extracted_data_raw.strip().split('\n')

    print("Processing and associating PaddleOCR English Output with Blocks (Simplified):")

    # Filter out "Warzone #27" lines and extract text/confidence
    player_lines = []
    for line in lines:
        parts = line.split(', Confidence:')
        if len(parts) == 2:
            text_part = parts[0].replace('Text:', '').strip()
            confidence_str = parts[1].strip()
            try:
                confidence = float(confidence_str)
            except ValueError:
                confidence = 0 # Default confidence if parsing fails

            # Keep lines that are NOT "Warzone #27"
            if "Warzone" not in text_part or "#" not in text_part:
                 player_lines.append({'text': text_part, 'confidence': confidence})


    # Now, associate these player lines with blocks based on their order
    # Assuming the order of player lines in the OCR output corresponds to the order of player blocks
    # 'player_blocks' should be defined from the first part of this combined cell execution
    if player_blocks: # Check if player_blocks was successfully populated
        num_blocks = len(player_blocks)
        num_player_lines = len(player_lines)

        if num_player_lines == num_blocks:
            print(f"  Number of player lines ({num_player_lines}) matches number of blocks ({num_blocks}). Associating based on order.")
            for i, player_line in enumerate(player_lines):
                block_index = i + 1 # 1-based index

                text = player_line['text']
                confidence = player_line['confidence']

                # Parse clan tag and username from the text
                clan_tag = None
                username = text.strip() # Default to whole text as username

                match = re.search(r'\[(.*?)\]', text)
                if match:
                    clan_tag = match.group(1).strip()
                    username_part = text[text.find(']') + 1:].strip()
                    username = username_part # Take everything after the bracket as username

                # Add to final parsed data dictionary, grouped by block
                if block_index not in final_parsed_data_for_grouping_by_block:
                     final_parsed_data_for_grouping_by_block[block_index] = []

                final_parsed_data_for_grouping_by_block[block_index].append({
                    'block': block_index,
                    'clan_tag': clan_tag,
                    'username': username,
                    'confidence': confidence, # Confidence of this specific text line
                    'original_text': text # Keep original text for verification
                })

        elif num_player_lines > 0:
            print(f"  Warning: Number of player lines ({num_player_lines}) does not match number of blocks ({num_blocks}). Cannot reliably associate based on order.")
            print("  Attempting partial association based on order up to the minimum count.")
            min_count = min(num_blocks, num_player_lines)
            for i in range(min_count):
                 block_index = i + 1 # 1-based index

                 text = player_lines[i]['text']
                 confidence = player_lines[i]['confidence']

                 clan_tag = None
                 username = text.strip()

                 match = re.search(r'\[(.*?)\]', text)
                 if match:
                     clan_tag = match.group(1).strip()
                     username_part = text[text.find(']') + 1:].strip()
                     username = username_part

                 if block_index not in final_parsed_data_for_grouping_by_block:
                     final_parsed_data_for_grouping_by_block[block_index] = []

                 final_parsed_data_for_grouping_by_block[block_index].append({
                     'block': block_index,
                     'clan_tag': clan_tag,
                     'username': username,
                     'confidence': confidence,
                     'original_text': text
                 })

        else:
            print("  No player lines found in OCR output after filtering.")
            final_parsed_data_for_grouping_by_block = {}


    else: # Handle case where player_blocks was empty
         print("Error: 'player_blocks' variable is empty. Cannot perform association.")
         final_parsed_data_for_grouping_by_block = {}


    print("\nFinished processing and associating PaddleOCR output with Blocks (Simplified).")
    print("\nParsed and Associated Data (Grouped by Block):")
    if final_parsed_data_for_grouping_by_block:
        for block_index, entries in final_parsed_data_for_grouping_by_block.items():
            print(f"Block {block_index}:")
            for entry in entries:
                 print(f"  Clan Tag: {entry['clan_tag']}\n  Username: {entry['username']}\n  Confidence: {entry['confidence']:.2f}\n  ---")
    else:
        print("No parsed and associated data generated.")


except FileNotFoundError as e:
    print(e)
except Exception as e:
    print(f"An error occurred: {e}")